{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-60bdf8d0e552ec5d3a53d88ca0bf2480f6f18423",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ClaudioLegalAgreement.sol": "project/contracts/ClaudioLegalAgreement.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ClaudioLegalAgreement.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title ClaudioLegalAgreement\n * @dev Smart contract for registering and tracking legal agreements between two parties\n * @notice This contract allows employers and coworkers to create and sign legal agreements on-chain\n */\ncontract ClaudioLegalAgreement {\n    \n    struct Agreement {\n        address employer;\n        address coworker;\n        bool employerSigned;\n        bool coworkerSigned;\n        uint256 createdAt;\n        bool exists;\n    }\n    \n    mapping(bytes32 => Agreement) public agreements;\n    \n    mapping(bytes32 => mapping(address => bool)) public hasSignedMapping;\n    \n    uint256 public totalAgreements;\n    \n    address public immutable claudioAddress;\n    \n    event AgreementCreated(bytes32 indexed caseId, address indexed employer, address indexed coworker);\n    event AgreementSigned(bytes32 indexed caseId, address indexed signer);\n    event AgreementCompleted(bytes32 indexed caseId);\n    \n    error AgreementAlreadyExists(bytes32 caseId);\n    error AgreementNotFound(bytes32 caseId);\n    error NotAuthorizedSigner(bytes32 caseId, address signer);\n    error AlreadySigned(bytes32 caseId, address signer);\n    error InvalidAddress();\n    error SameAddress();\n    error NotAuthorizedCreator(address sender);\n    \n    modifier agreementExists(bytes32 caseId) {\n        if (!agreements[caseId].exists) {\n            revert AgreementNotFound(caseId);\n        }\n        _;\n    }\n    \n    modifier validAddress(address addr) {\n        if (addr == address(0)) {\n            revert InvalidAddress();\n        }\n        _;\n    }\n    \n    modifier authorizedSigner(bytes32 caseId) {\n        Agreement storage agreement = agreements[caseId];\n        if (msg.sender != agreement.employer && msg.sender != agreement.coworker) {\n            revert NotAuthorizedSigner(caseId, msg.sender);\n        }\n        _;\n    }\n    \n    modifier onlyClaudio() {\n        if (msg.sender != claudioAddress) {\n            revert NotAuthorizedCreator(msg.sender);\n        }\n        _;\n    }\n    \n    constructor(address _claudioAddress) validAddress(_claudioAddress) {\n        claudioAddress = _claudioAddress;\n    }\n    \n    /**\n     * @dev Creates a new legal agreement between employer and coworker\n     * @param caseId Unique identifier for the agreement (converted to bytes32)\n     * @param employer Address of the employer party\n     * @param coworker Address of the coworker party\n     */\n    function createAgreement(\n        string calldata caseId,\n        address employer,\n        address coworker\n    ) external onlyClaudio validAddress(employer) validAddress(coworker) {\n        if (employer == coworker) {\n            revert SameAddress();\n        }\n        \n        bytes32 caseIdHash = keccak256(abi.encodePacked(caseId));\n        \n        if (agreements[caseIdHash].exists) {\n            revert AgreementAlreadyExists(caseIdHash);\n        }\n        \n        agreements[caseIdHash] = Agreement({\n            employer: employer,\n            coworker: coworker,\n            employerSigned: false,\n            coworkerSigned: false,\n            createdAt: block.timestamp,\n            exists: true\n        });\n        \n        totalAgreements++;\n        \n        emit AgreementCreated(caseIdHash, employer, coworker);\n    }\n    \n    /**\n     * @dev Alternative function using bytes32 directly for gas efficiency\n     * @param caseIdHash Pre-hashed case ID\n     * @param employer Address of the employer party\n     * @param coworker Address of the coworker party\n     */\n    function createAgreementWithHash(\n        bytes32 caseIdHash,\n        address employer,\n        address coworker\n    ) external onlyClaudio validAddress(employer) validAddress(coworker) {\n        if (employer == coworker) {\n            revert SameAddress();\n        }\n        \n        if (agreements[caseIdHash].exists) {\n            revert AgreementAlreadyExists(caseIdHash);\n        }\n        \n        agreements[caseIdHash] = Agreement({\n            employer: employer,\n            coworker: coworker,\n            employerSigned: false,\n            coworkerSigned: false,\n            createdAt: block.timestamp,\n            exists: true\n        });\n        \n        totalAgreements++;\n        \n        emit AgreementCreated(caseIdHash, employer, coworker);\n    }\n    \n    /**\n     * @dev Sign an agreement using string caseId\n     * @param caseId String identifier of the agreement to sign\n     */\n    function signAgreement(string calldata caseId) \n        external \n    {\n        bytes32 caseIdHash = keccak256(abi.encodePacked(caseId));\n        _signAgreement(caseIdHash);\n    }\n    \n    /**\n     * @dev Sign an agreement using bytes32 caseId for gas efficiency\n     * @param caseIdHash Hash of the case ID to sign\n     */\n    function signAgreementWithHash(bytes32 caseIdHash) \n        external \n    {\n        _signAgreement(caseIdHash);\n    }\n    \n    /**\n     * @dev Internal function to handle agreement signing logic\n     * @param caseIdHash Hash of the case ID to sign\n     */\n    function _signAgreement(bytes32 caseIdHash) \n        internal \n        agreementExists(caseIdHash) \n        authorizedSigner(caseIdHash) \n    {\n        Agreement storage agreement = agreements[caseIdHash];\n        \n        if (hasSignedMapping[caseIdHash][msg.sender]) {\n            revert AlreadySigned(caseIdHash, msg.sender);\n        }\n        \n        if (msg.sender == agreement.employer) {\n            agreement.employerSigned = true;\n        } else {\n            agreement.coworkerSigned = true;\n        }\n        \n        hasSignedMapping[caseIdHash][msg.sender] = true;\n        \n        emit AgreementSigned(caseIdHash, msg.sender);\n        \n        if (agreement.employerSigned && agreement.coworkerSigned) {\n            emit AgreementCompleted(caseIdHash);\n        }\n    }\n    \n    /**\n     * @dev Check if a specific address has signed an agreement\n     * @param caseId String identifier of the agreement\n     * @param signer Address to check\n     * @return bool indicating if the address has signed\n     */\n    function hasSigned(string calldata caseId, address signer) \n        external \n        view \n        returns (bool) \n    {\n        bytes32 caseIdHash = keccak256(abi.encodePacked(caseId));\n        return hasSignedMapping[caseIdHash][signer];\n    }\n    \n    /**\n     * @dev Check if a specific address has signed an agreement (bytes32 version)\n     * @param caseIdHash Hash of the case ID\n     * @param signer Address to check\n     * @return bool indicating if the address has signed\n     */\n    function hasSignedWithHash(bytes32 caseIdHash, address signer) \n        external \n        view \n        returns (bool) \n    {\n        return hasSignedMapping[caseIdHash][signer];\n    }\n    \n    /**\n     * @dev Check if an agreement is completed (both parties signed)\n     * @param caseId String identifier of the agreement\n     * @return bool indicating if the agreement is completed\n     */\n    function isCompleted(string calldata caseId) \n        external \n        view \n        returns (bool) \n    {\n        bytes32 caseIdHash = keccak256(abi.encodePacked(caseId));\n        Agreement storage agreement = agreements[caseIdHash];\n        return agreement.exists && agreement.employerSigned && agreement.coworkerSigned;\n    }\n    \n    /**\n     * @dev Check if an agreement is completed (bytes32 version)\n     * @param caseIdHash Hash of the case ID\n     * @return bool indicating if the agreement is completed\n     */\n    function isCompletedWithHash(bytes32 caseIdHash) \n        external \n        view \n        returns (bool) \n    {\n        Agreement storage agreement = agreements[caseIdHash];\n        return agreement.exists && agreement.employerSigned && agreement.coworkerSigned;\n    }\n    \n    /**\n     * @dev Get agreement details\n     * @param caseId String identifier of the agreement\n     * @return Agreement struct with all details\n     */\n    function getAgreement(string calldata caseId) \n        external \n        view \n        returns (Agreement memory) \n    {\n        bytes32 caseIdHash = keccak256(abi.encodePacked(caseId));\n        return agreements[caseIdHash];\n    }\n    \n    /**\n     * @dev Get agreement details (bytes32 version)\n     * @param caseIdHash Hash of the case ID\n     * @return Agreement struct with all details\n     */\n    function getAgreementWithHash(bytes32 caseIdHash) \n        external \n        view \n        returns (Agreement memory) \n    {\n        return agreements[caseIdHash];\n    }\n    \n    /**\n     * @dev Utility function to compute caseId hash off-chain validation\n     * @param caseId String to hash\n     * @return bytes32 hash of the caseId\n     */\n    function computeCaseIdHash(string calldata caseId) \n        external \n        pure \n        returns (bytes32) \n    {\n        return keccak256(abi.encodePacked(caseId));\n    }\n}"
      }
    }
  }
}